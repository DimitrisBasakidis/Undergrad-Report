\begin{abstract}
\noindent
\note{jk: Fix the problem statement. The problem here is that DRAM cannot scale so systems like TeraHeap
use fast storage devices to extend their heap. Then you have to say that these
systems to avoid large GC pause time they use two heaps: a primary heap over DRAM and
a second heap over storage device. Say that they use I/O cache to reduce slow
accesses to the storage device. These systems thy need to divide dynamically the
DRAM between H1 and I/O cache for H2.}
Managed runtimes must efficiently balance memory allocation across dynamically
changing workloads, especially when operating under constrained DRAM
environments. TeraHeap enhances the G1 Garbage Collector by logically the Java
heap into two regions: H1, optimized for GC-managed short-lived objects, and H2,
used for longer-lived data with reduced GC overheads. However, TeraHeap
statically relies on a fixed total heap size and does not adapt to variations in
application memory pressure or available system resources.

In this work, we extend TeraHeap with a dynamic heap resizer that adjusts the
heap size at runtime based on total lost compute cycles, combining both
GC-induced CPU contention and I/O wait delays. Our resizer uses a lightweight
policy engine that monitors metrics such as GC and I/O wait time to decide
whether to grow or shrink the heap. This dynamic resizing mechanism is fully
integrated into the OpenJDKâ€™s G1 TeraHeap implementation and requires no manual
tuning or application-specific knowledge.

We evaluate our system on Lucene, a widely used full-text search engine, under
varied memory-constrained scenarios. Our results show that the dynamic heap
resizer improves adaptability and performance stability across workloads. It
effectively reclaims memory during idle periods to reduce system pressure and
reallocates heap space under load to maintain throughput, outperforming the
baseline TeraHeap configuration in both responsiveness and efficiency.
\end{abstract}
