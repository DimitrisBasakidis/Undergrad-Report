\section{Background}

\note{jk: Your background should discuss the GC types of G1 (young, mixed, full
	GCs), when objects are moved from H1 to H2}


\subsection{TeraHeap}
TeraHeap extends the Garbage-Collector's JVM (G1) by introducing a
secondary heap (H2) which is a memory-mapped file on a storage device. TeraHeap
provides a hint-based interface, where applications can mark which objects to
move to H2. In the next mixed or full GC cycle, TeraHeap transfers the
transitive closure of the marked objects from H1 to the H2. All the accesses to
H2 objects go through the OS page cache.

\subsection{GC Types in G1-Garbage Collector} In the G1 garbage collector, GC
overheads occur from 3 key mechanisms that operate either at safepoints or
concurrently with the application. These contributors to GC-related CPU
overhead are:

\textbf{1. Stop-the-World (STW) Pauses:}  G1 performs certain tasks such as
root scanning, object copying, or final marking and heap related operations
like young generation collections, mixed collections and full GCs. Such phases
are exeuted in safepoints where all application (mutator) threads are
suspended. These are called \emph{stop-the-world} events and directly block
application execution resulting in major latency spikes.

\textbf{2. Concurrent GC Threads:}  To reduce pause times, G1 assigns specific
GC work to dedicated concurrent threads that run alongside the executors. These
threads are responsible for concurrent markings. While these operations are
designed to be background activities, they still consume CPU cycles, due to
context switches. Also, if the number of GC threads plus mutator threads
exceeds the available CPU cores, they compete for CPU time, leading to
potential application slowdowns due to oversubscription.

\textbf{3. Refinement Threads:}  G1 uses a card table and remembered sets to
track cross-region references. Refinement threads are responsible for updating
these remembered sets with references to objects existing in the old
generation. This mechanism ensures correctness during evacuation but introduces
additional CPU overhead, especially under write-heavy workloads.


